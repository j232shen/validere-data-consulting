---
title: "Portfolio Simulations"
author: "Jane Shen"
format: html
editor: visual
---

```{r}
#| label: setup

library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(CVXR)
library(xts)

source("ETL.R")
```

## Get data

```{r}
#| label: process-assets

# fixed asset universe
# SPY: large cap equity (for comparison)
# VTI: all public U.S. stocks
# VXUS: most non-U.S. stocks
# BND: broad U.S. investment-grade bonds
# BNDX: broad non-U.S. bonds

start_date <- "2013-06-05" # inception date for BNDX
end_date <- "2025-06-30"

tickers <- list(VTI = "VTI", VXUS = "VXUS", BND = "BND", BNDX = "BNDX")

# get returns and prices
clean_returns <- get_all_log_returns(tickers, from = start_date, to = end_date)
clean_prices <- get_all_adj_close(tickers, from = start_date, to = end_date)

colnames(clean_returns)
```

## Optimization functions

```{r}
# optimize_portfolio <- function(returns, pspec) {
#   # run quarterly rebalancing backtest
#   opt.rebal <- optimize.portfolio.rebalancing(returns, pspec,
#                                               optimize_method="CVXR",
#                                               rebalance_on="months",
#                                               # training_period=3 * 252, # 3 years is the default
#                                               rolling_window=3 * 252)
# 
#   return(opt.rebal)
# }
# 
# 
# print_opt_summary <- function(opt.rebal) {
#   summary_results <- summary(opt.rebal)
#   annualized_return <- summary_results$annualized_returns 
#   paste0("Annualized return:", annualized_return)
# }
# 
# 
# get_opt_returns <- function(returns, opt.rebal) {
#   # extract optimal weights from optimization
#   weights <- extractWeights(opt.rebal)
#   weights <- weights[complete.cases(weights),]
# 
#   # compute optimized portfolio returns
#   opt.returns <- Return.rebalancing(returns, weights)
# 
#   return(opt.returns)
# }
# 
# 
# plot_backtest <- function(opt.returns) {
#   backtest.plot(opt.returns)
# }
# 
# 
# backtest_portfolio <- function(returns, pspec) {
#   opt.rebal <- optimize.portfolio(returns, pspec)
#   print_opt_summary(opt.rebal)
#   opt.returns <- get_opt_returns(returns, opt.rebal)
#   plot_backtest(opt.returns)
# }
```

```{r}
# reusable function for running portfolio simulation
backtest_portfolio <- function(returns, pspec) {
  opt.rebal <- optimize.portfolio.rebalancing(returns, pspec,
                                              optimize_method="CVXR",
                                              rebalance_on="quarters",
                                              # training_period=3 * 252, # 3 years is the default
                                              rolling_window=3 * 252)
  
  # extract optimal weights from regime-switching optimization  
  weights <- extractWeights(opt.rebal)  
  weights <- weights[complete.cases(weights),]  
    
  # compute optimized portfolio returns  
  returns <- Return.rebalancing(clean_returns, weights)  # rebalancing covered by weights object
  
  # get annualized performance metrics  
  summary_results <- summary(opt.rebal)  
  annualized_return <- summary_results$annualized_returns 
  
  # # plot backtest results
  # backtest.plot(returns)
  
  return(list(weights = weights, returns = returns))
}


# DCA simulation function
dca_portfolio_simulation <- function(prices_xts, weights_xts, inflow_amount = 1000, initial_cash = 0) {
  dates <- index(weights_xts)
  n_assets <- ncol(weights_xts)
  holdings <- rep(0, n_assets)
  cash <- initial_cash
  portfolio_value <- numeric(length(dates))
  # colnames(holdings) <- colnames(prices_xts)
  
  # align prices to weights dates
  prices_xts <- prices_xts[dates, ]
  
  for (i in seq_along(dates)) {
    # add new cash inflow
    cash <- cash + inflow_amount
    
    # get prices for this date
    prices <- as.numeric(prices_xts[i, ])
    
    # allocate cash according to weights
    w <- as.numeric(weights_xts[i, ])
    invest_amounts <- cash * w
    shares_bought <- invest_amounts / prices
    shares_bought[is.na(shares_bought)] <- 0  # handle any NA prices
    holdings <- holdings + shares_bought
    cash <- 0  # all cash invested
    
    # update holdings for next period's returns (if not last period)
    if (i < length(dates)) {
      next_prices <- as.numeric(prices_xts[i + 1, ])
      returns <- (next_prices - prices) / prices
      holdings <- holdings * (1 + returns)
    }
    
    # calculate portfolio value
    portfolio_value[i] <- sum(holdings * prices) + cash
  }
  
  # return as xts
  portfolio_value_xts <- xts(portfolio_value, order.by = dates)
  colnames(portfolio_value_xts) <- "Portfolio.Value"
  return(portfolio_value_xts)
}
```

## Define portfolio allocations

### 60/40 equities to bonds

```{r}
# create portfolio specification
pspec_1 <- portfolio.spec(assets = colnames(clean_returns))

# add full investment constraint
pspec_1 <- add.constraint(pspec_1, type = "full_investment")

# add group constraints
pspec_1 <- add.constraint(pspec_1, type = "group",
                          groups = list(equities = c(1, 2),  # US + global equities
                                        bonds = c(3, 4)),    # US + global bonds
                          group_min = c(0.58, 0.38),         # 60% equities, 40% bonds with some flexibility
                          group_max = c(0.62, 0.42))

# add nested constraints within asset class allocation
pspec_1 <- add.constraint(pspec_1, type = "group",  
                          groups = list(VTI = 1, VXUS = 2, BND = 3, BNDX = 4),  
                          group_min = c(0.34, 0.22, 0.26, 0.10), 
                          group_max = c(0.38, 0.26, 0.30, 0.14))

# add objectives: maximize mean return while minimizing var
pspec_1 <- add.objective(pspec_1, type = "return", name = "mean")  
pspec_1 <- add.objective(pspec_1, type = "risk", name = "ES")

results_1 <- backtest_portfolio(clean_returns, pspec_1)
```

```{r}
# DCA simulation
dca_portfolio <- dca_portfolio_simulation(clean_prices, results_1$weights, inflow_amount = 1000, initial_cash = 0)

# plot results
plot(dca_portfolio, main = "Portfolio Value with Dollar Cost Averaging") # , ylab = "Portfolio Value ($)")

# calculate DCA returns
dca_returns <- Return.calculate(dca_portfolio)
charts.PerformanceSummary(dca_returns, main = "DCA Portfolio Performance")
```

### 100% equity

```{r}
# create portfolio specification
pspec_2 <- portfolio.spec(assets = colnames(clean_returns)[1:2])  # only equities

# add full investment constraint
pspec_2 <- add.constraint(pspec_2, type = "full_investment")

# add group constraints
pspec_2 <- add.constraint(pspec_2, type = "group",
                          groups = list(VTI = 1, VXUS = 2),
                          group_min = c(0.58, 0.38),  # 60% US, 40% global
                          group_max = c(0.62, 0.42))

# add objectives: maximize mean return while minimizing var
pspec_2 <- add.objective(pspec_2, type = "return", name = "mean")  
pspec_2 <- add.objective(pspec_2, type = "risk", name = "ES")

results_2 <- backtest_portfolio(clean_returns, pspec_2)
```

### 100% MTUM

```{r}
MTUM_returns <- process_assets(list("MTUM"), from = start_date, to = end_date)
colnames(MTUM_returns)

# create a weight matrix that's always 100% MTUM
mtum_dates <- index(MTUM_returns)  
mtum_weights <- xts(matrix(1, nrow=length(mtum_dates), ncol=1), order.by=mtum_dates)  
colnames(mtum_weights) <- "MTUM"  

# get "rebalanced" returns for consistency
MTUM_portfolio <- Return.rebalancing(MTUM_returns, mtum_weights)
```

### Vanguard Target Retirement 2025 Fund

```{r}
VTTVX_returns <- process_assets(list("VTTVX"), from = start_date, to = end_date)
colnames(VTTVX_returns)

# create a weight matrix that's always 100% VTTVX
vttvx_dates <- index(VTTVX_returns)  
vttvx_weights <- xts(matrix(1, nrow=length(vttvx_dates), ncol=1), order.by=vttvx_dates)  
colnames(vttvx_weights) <- "VTTVX"  

# get "rebalanced" returns for consistency
VTTVX_portfolio <- Return.rebalancing(VTTVX_returns, vttvx_weights)
```

## Group portfolios and simulate

```{r}
grouped_returns <- na.omit(merge(results_1$returns, 
                                 results_2$returns, 
                                 MTUM_portfolio, 
                                 VTTVX_portfolio,
                                 all=FALSE))  # get rid of rows that don't align with the rebalancing dates
names(grouped_returns) <- c("60/40", "100% Equity", "100% Momentum", "Vanguard Target 2025 Fund")  

backtest.plot(grouped_returns)
```
