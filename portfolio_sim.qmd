---
title: "Portfolio Simulations"
author: "Jane Shen"
format: html
editor: visual
---

```{r}
#| label: setup

library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(CVXR)
library(xts)
library(zoo)

source("ETL.R")
```

## Get data

```{r}
#| label: process-assets

# fixed asset universe
# SPY: large cap equity (for comparison)
# VTI: all public U.S. stocks
# VXUS: most non-U.S. stocks
# BND: broad U.S. investment-grade bonds
# BNDX: broad non-U.S. bonds

start_date <- "2013-06-05" # inception date for BNDX
end_date <- "2025-06-30"

tickers <- list(VTI = "VTI", VXUS = "VXUS", BND = "BND", BNDX = "BNDX")

# get returns and adjusted close prices
clean_returns <- get_all_log_returns(tickers, from = start_date, to = end_date)
clean_prices <- get_all_adj_close(tickers, from = start_date, to = end_date)

colnames(clean_returns)
```

## Optimization functions

```{r}
# optimize_portfolio <- function(returns, pspec) {
#   # run quarterly rebalancing backtest
#   opt.rebal <- optimize.portfolio.rebalancing(returns, pspec,
#                                               optimize_method="CVXR",
#                                               rebalance_on="months",
#                                               # training_period=3 * 252, # 3 years is the default
#                                               rolling_window=3 * 252)
# 
#   return(opt.rebal)
# }
# 
# 
# print_opt_summary <- function(opt.rebal) {
#   summary_results <- summary(opt.rebal)
#   annualized_return <- summary_results$annualized_returns 
#   paste0("Annualized return:", annualized_return)
# }
# 
# 
# get_opt_returns <- function(returns, opt.rebal) {
#   # extract optimal weights from optimization
#   weights <- extractWeights(opt.rebal)
#   weights <- weights[complete.cases(weights),]
# 
#   # compute optimized portfolio returns
#   opt.returns <- Return.rebalancing(returns, weights)
# 
#   return(opt.returns)
# }
# 
# 
# plot_backtest <- function(opt.returns) {
#   backtest.plot(opt.returns)
# }
# 
# 
# backtest_portfolio <- function(returns, pspec) {
#   opt.rebal <- optimize.portfolio(returns, pspec)
#   print_opt_summary(opt.rebal)
#   opt.returns <- get_opt_returns(returns, opt.rebal)
#   plot_backtest(opt.returns)
# }
```

```{r}
# reusable function for running portfolio simulation
backtest_portfolio <- function(returns, pspec) {
  opt.rebal <- optimize.portfolio.rebalancing(returns, pspec,
                                              optimize_method="CVXR",
                                              rebalance_on="months",
                                              # training_period=3 * 252, # 3 years is the default
                                              rolling_window=3 * 252)
  
  # extract optimal weights from regime-switching optimization  
  weights <- extractWeights(opt.rebal)  
  weights <- weights[complete.cases(weights),]  
    
  # compute optimized portfolio returns  
  returns <- Return.rebalancing(clean_returns, weights)  # rebalancing covered by weights object
  
  # get annualized performance metrics  
  summary_results <- summary(opt.rebal)  
  annualized_return <- summary_results$annualized_returns 
  
  # # plot backtest results
  # backtest.plot(returns)
  
  return(list(weights = weights, returns = returns))
}


dca_portfolio_simulation <- function(prices_xts, weights_xts, inflow_amount = 1000, initial_cash = 0) {
  dates <- index(weights_xts)
  n_assets <- ncol(weights_xts)
  holdings <- rep(0, n_assets)
  cash <- initial_cash
  portfolio_value <- numeric(length(dates))
  
  # align prices to weights dates
  prices_xts <- prices_xts[dates, ]
  
  for (i in seq_along(dates)) {
    # add new cash inflow
    cash <- cash + inflow_amount
    
    # get prices for this date
    prices <- as.numeric(prices_xts[i, ])
    
    # FULL REBALANCING: allocate total portfolio value according to weights
    w <- as.numeric(weights_xts[i, ])
    current_holdings_value <- sum(holdings * prices)
    total_value <- current_holdings_value + cash
    target_value <- total_value * w
    holdings <- target_value / prices
    holdings[is.na(holdings)] <- 0  # handle any NA prices
    cash <- 0  # all cash invested
    
    # calculate portfolio value for this period
    portfolio_value[i] <- sum(holdings * prices)
  }
  
  # return as xts
  portfolio_value_xts <- xts(portfolio_value, order.by = dates)
  colnames(portfolio_value_xts) <- "Portfolio.Value"
  return(portfolio_value_xts)
}


calculate_irr <- function(dca_portfolio, monthly_contribution = 1000) {
  n_periods <- length(dca_portfolio)

  # construct cash flows: -1000 each month, final portfolio value as last cash flow
  cash_flows <- rep(-monthly_contribution, n_periods)
  cash_flows[n_periods] <- as.numeric(dca_portfolio[n_periods])  # replace last inflow with final portfolio value

  # IRR using uniroot
  monthly_irr <- uniroot(
    function(r) sum(cash_flows * (1 + r)^-(0:(n_periods - 1))),
    interval = c(-0.99, 1),  # allow for negative returns
    tol = 1e-8
  )$root

  annual_irr <- (1 + monthly_irr)^12 - 1

  return(list(monthly = monthly_irr, annual = annual_irr))
}
```

## Define portfolio allocations

```{r}
cf = 3000  # monthly cash inflow
```

### 60/40 equities to bonds

```{r}
# create portfolio specification
spec_60_40 <- portfolio.spec(assets = colnames(clean_returns))

# add full investment constraint
spec_60_40 <- add.constraint(spec_60_40, type = "full_investment")

# add group constraints
spec_60_40 <- add.constraint(spec_60_40, type = "group",
                             groups = list(equities = c(1, 2),  # US + global equities
                                           bonds = c(3, 4)),    # US + global bonds
                             group_min = c(0.58, 0.38),         # 60% equities, 40% bonds with some flexibility
                             group_max = c(0.62, 0.42))

# add nested constraints within asset class allocation
spec_60_40 <- add.constraint(spec_60_40, type = "group",  
                             groups = list(VTI = 1, VXUS = 2, BND = 3, BNDX = 4),  
                             group_min = c(0.34, 0.22, 0.26, 0.10), 
                             group_max = c(0.38, 0.26, 0.30, 0.14))

# add objectives: maximize mean return while minimizing var
spec_60_40 <- add.objective(spec_60_40, type = "return", name = "mean")  
spec_60_40 <- add.objective(spec_60_40, type = "risk", name = "ES")

results_60_40 <- backtest_portfolio(clean_returns, spec_60_40)
```

```{r}
# DCA simulation
dca_60_40 <- dca_portfolio_simulation(clean_prices, results_60_40$weights, inflow_amount = cf, initial_cash = 0)

# plot portfolio value
plot(dca_60_40, main = "Portfolio Value with Dollar Cost Averaging") # , ylab = "Portfolio Value ($)")

# manually calculate drawdowns from portfolio values
cummax_values <- cummax(dca_60_40)
drawdowns_60_40 <- (dca_60_40 / cummax_values) - 1
plot(drawdowns_60_40, main = "Drawdowns (DCA Portfolio)", ylab = "Drawdown", xlab = "Date")

# calculate IRR (money-adjusted return)
irr_60_40 <- calculate_irr(dca_60_40, monthly_contribution = cf)
print(irr_60_40)
```

Sanity check:

```{r}
inflow_amount = cf
dca_portfolio <- dca_60_40
weights_xts <- results_60_40$weights
prices_xts <- clean_prices

# 1. Total invested
cat("Total invested:", inflow_amount * length(index(weights_xts)), "\n")

# 2. Final portfolio value
cat("Final portfolio value:", as.numeric(tail(dca_portfolio, 1)), "\n")

# 3. Price range
print(range(prices_xts, na.rm = TRUE))

# 4. Weight range
print(range(weights_xts, na.rm = TRUE))

# 5. Any NAs or zeros in prices?
cat("Any NAs in prices:", any(is.na(prices_xts)), "\n")
cat("Any zeros in prices:", any(prices_xts == 0, na.rm = TRUE), "\n")

# 6. Any NAs or negatives in weights?
cat("Any NAs in weights:", any(is.na(weights_xts)), "\n")
cat("Any negatives in weights:", any(weights_xts < 0, na.rm = TRUE), "\n")
```

Compare to static weights

```{r}
# static weights matrix (no rebalancing) for comparison
rebalance_dates <- index(results_60_40$weights)

static_weights <- matrix(
  c(0.36, 0.24, 0.28, 0.12),  # VTI, VXUS, BND, BNDX
  nrow = length(rebalance_dates),
  ncol = 4,
  byrow = TRUE
)
colnames(static_weights) <- c("VTI", "VXUS", "BND", "BNDX")
static_weights_xts <- xts(static_weights, order.by = rebalance_dates)

dca_static_60_40 <- dca_portfolio_simulation(clean_prices, static_weights_xts, inflow_amount = cf, initial_cash = 0)

# compare IRR
calculate_irr(dca_static_60_40, monthly_contribution = cf)
```

### 100% equity

```{r}
# create portfolio specification
spec_full_equity <- portfolio.spec(assets = colnames(clean_returns)[1:2])  # only equities

# add full investment constraint
spec_full_equity <- add.constraint(spec_full_equity, type = "full_investment")

# add group constraints
spec_full_equity <- add.constraint(spec_full_equity, type = "group",
                                   groups = list(VTI = 1, VXUS = 2),
                                   group_min = c(0.58, 0.38),  # 60% US, 40% global
                                   group_max = c(0.62, 0.42))

# add objectives: maximize mean return while minimizing var
spec_full_equity <- add.objective(spec_full_equity, type = "return", name = "mean")  
spec_full_equity <- add.objective(spec_full_equity, type = "risk", name = "ES")

results_full_equity <- backtest_portfolio(clean_returns, spec_full_equity)
```

```{r}
# DCA simulation
equity_prices <- clean_prices[, c("VTI", "VXUS")]  # subset equity prices
dca_full_equity <- dca_portfolio_simulation(equity_prices, results_full_equity$weights, inflow_amount = cf, initial_cash = 0)

# plot results
plot(dca_full_equity, main = "Portfolio Value with Dollar Cost Averaging") # , ylab = "Portfolio Value ($)")

# manually calculate drawdowns from portfolio values
cummax_values <- cummax(dca_full_equity)
drawdowns_full_equity <- (dca_full_equity / cummax_values) - 1
plot(drawdowns_full_equity, main = "Drawdowns (DCA Portfolio)", ylab = "Drawdown", xlab = "Date")

# calculate IRR (money-adjusted return)
irr_full_equity <- calculate_irr(dca_full_equity, monthly_contribution = cf)
print(irr_full_equity)
```

Compare to static weights

```{r}
# static weights matrix for 100% equity comparison
equity_rebalance_dates <- index(results_full_equity$weights)

# sreate static weights matrix (60% VTI, 40% VXUS - same for all periods)
static_equity_weights <- matrix(
  c(0.6, 0.4),  # VTI, VXUS
  nrow = length(equity_rebalance_dates),
  ncol = 2,
  byrow = TRUE
)
colnames(static_equity_weights) <- c("VTI", "VXUS")
static_equity_weights_xts <- xts(static_equity_weights, order.by = equity_rebalance_dates)

# run DCA simulation with static weights
dca_static_equity <- dca_portfolio_simulation(clean_prices[, c("VTI", "VXUS")], 
                                            static_equity_weights_xts, 
                                            inflow_amount = cf, initial_cash = 0)

# calculate IRR for static allocation
print("Static 60/40 Equity IRR:")
calculate_irr(dca_static_equity, monthly_contribution = cf)

# Compare with optimized version
print("Optimized Equity IRR:")
calculate_irr(dca_full_equity, monthly_contribution = cf)
```

### 100% MTUM

```{r}
# LUMP SUM INVESTMENT
MTUM_returns <- get_all_log_returns(list("MTUM"), from = start_date, to = end_date)
colnames(MTUM_returns)

# create a weight matrix that's always 100% MTUM
mtum_dates <- index(MTUM_returns)  
mtum_weights <- xts(matrix(1, nrow=length(mtum_dates), ncol=1), order.by=mtum_dates)  
colnames(mtum_weights) <- "MTUM"  

# get "rebalanced" returns for consistency
MTUM_portfolio <- Return.rebalancing(MTUM_returns, mtum_weights)
```

```{r}
# get the rebalancing dates from optimized portfolio
rebalance_dates <- index(results_60_40$weights)  # weights_xts from your optimized portfolio

# get adjusted close prices for MTUM and subset to rebalance dates
mtum_prices_full <- get_all_adj_close(list("MTUM"), from = start_date, to = end_date)
mtum_prices <- mtum_prices_full[rebalance_dates, , drop = FALSE]

# weights always 1 for MTUM
mtum_weights <- xts(matrix(1, nrow=nrow(mtum_prices), ncol=1), order.by=index(mtum_prices))
colnames(mtum_weights) <- "MTUM"

# DCA simulation
dca_mtum <- dca_portfolio_simulation(mtum_prices, mtum_weights, inflow_amount = cf, initial_cash = 0)

# plot results
plot(dca_mtum, main = "Portfolio Value with Dollar Cost Averaging") # , ylab = "Portfolio Value ($)")

# manually calculate drawdowns from portfolio values
cummax_values <- cummax(dca_mtum)
drawdowns_mtum <- (dca_mtum / cummax_values) - 1
plot(drawdowns_mtum, main = "Drawdowns (DCA Portfolio)", ylab = "Drawdown", xlab = "Date")

# calculate IRR (money-adjusted return)
irr_mtum <- calculate_irr(dca_mtum, monthly_contribution = cf)
print(irr_mtum)
```

### Vanguard Target Retirement 2025 Fund

```{r}
# LUMP SUM INVESTMENT
VTTVX_returns <- get_all_log_returns(list("VTTVX"), from = start_date, to = end_date)
colnames(VTTVX_returns)

# create a weight matrix that's always 100% VTTVX
vttvx_dates <- index(VTTVX_returns)  
vttvx_weights <- xts(matrix(1, nrow=length(vttvx_dates), ncol=1), order.by=vttvx_dates)  
colnames(vttvx_weights) <- "VTTVX"  

# get "rebalanced" returns for consistency
VTTVX_portfolio <- Return.rebalancing(VTTVX_returns, vttvx_weights)
```

```{r}
# get the rebalancing dates from optimized portfolio
rebalance_dates <- index(results_60_40$weights)  # weights_xts from your optimized portfolio

# get adjusted close prices for MTUM and subset to rebalance dates
vttvx_prices_full <- get_all_adj_close(list("VTTVX"), from = start_date, to = end_date)
vttvx_prices <- vttvx_prices_full[rebalance_dates, , drop = FALSE]

# weights always 1 for MTUM
vttvx_weights <- xts(matrix(1, nrow=nrow(vttvx_prices), ncol=1), order.by=index(vttvx_prices))
colnames(vttvx_weights) <- "VTTVX"

# DCA simulation
dca_vttvx <- dca_portfolio_simulation(vttvx_prices, vttvx_weights, inflow_amount = cf, initial_cash = 0)

# plot results
plot(dca_vttvx, main = "Portfolio Value with Dollar Cost Averaging") # , ylab = "Portfolio Value ($)")

# manually calculate drawdowns from portfolio values
cummax_values <- cummax(dca_vttvx)
drawdowns_vttvx <- (dca_vttvx / cummax_values) - 1
plot(drawdowns_vttvx, main = "Drawdowns (DCA Portfolio)", ylab = "Drawdown", xlab = "Date")

# calculate IRR (money-adjusted return)
irr_vttvx <- calculate_irr(dca_vttvx, monthly_contribution = cf)
print(irr_vttvx)
```

## Group portfolios and simulate

### Lump Sum

```{r}
grouped_returns <- na.omit(merge(results_60_40$returns, 
                                 results_full_equity$returns, 
                                 MTUM_portfolio, 
                                 VTTVX_portfolio,
                                 all=FALSE))  # get rid of rows that don't align with the rebalancing dates
names(grouped_returns) <- c("60/40", "100% Equity", "100% Momentum", "Vanguard Target 2025 Fund")  

backtest.plot(grouped_returns)
```

### Dollar-cost Averaging (DCA)

```{r}
# set up plotting parameters
my_colors <- c("black", "red", "green", "blue")
my_legend <- c("60/40", "100% Equity", "100% Momentum", "Vanguard Target 2025 Fund")

# combine portfolio values
portfolio_values <- merge(dca_60_40, 
                         dca_full_equity, 
                         dca_mtum, 
                         dca_vttvx, 
                         all = FALSE)
colnames(portfolio_values) <- my_legend

# combine drawdowns
portfolio_drawdowns <- merge(drawdowns_60_40, 
                            drawdowns_full_equity, 
                            drawdowns_mtum, 
                            drawdowns_vttvx, 
                            all = FALSE)
colnames(portfolio_drawdowns) <- my_legend

# subplot layout
par(mfrow = c(2, 1), mar = c(3, 4, 3, 2))

# top plot: Portfolio Values
plot.xts(
  portfolio_values,
  main = "DCA Portfolio Values",
  # ylab = "Portfolio Value ($)",
  col = my_colors,
  lwd = 2,
  legend.loc = "topleft",
  legend.names = my_legend,
  major.ticks = "years",
  grid.col = "lightgray"
)

# bottom plot: drawdowns
plot.xts(
  portfolio_drawdowns * 100,  # Convert to percentage
  main = "Portfolio Drawdowns",
  ylab = "Drawdown (%)",
  xlab = "Date",
  col = my_colors,
  lwd = 2,
  major.ticks = "years",
  grid.col = "lightgray"
)

# reset plotting parameters
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Risk metrics

```{r}
# function to calculate maximum drawdown
calculate_max_drawdown <- function(portfolio_values) {
  cummax_values <- cummax(portfolio_values)
  drawdowns <- (portfolio_values / cummax_values) - 1
  max_dd <- min(drawdowns, na.rm = TRUE)
  return(max_dd)
}

# function to calculate portfolio volatility (annualized)
calculate_portfolio_volatility <- function(portfolio_values, frequency = 12) {
  # calculate log returns from portfolio values
  log_returns <- diff(log(portfolio_values))
  # annualized volatility
  volatility <- sd(log_returns, na.rm = TRUE) * sqrt(frequency)
  return(volatility)
}

# function to calculate modified Sharpe ratio for DCA
calculate_modified_sharpe <- function(irr, portfolio_values, risk_free_rate = 0.03) {
  excess_return <- irr - risk_free_rate
  volatility <- calculate_portfolio_volatility(portfolio_values)
  sharpe <- excess_return / volatility
  return(sharpe)
}

# function to calculate Sortino ratio for DCA
calculate_sortino_ratio <- function(irr, portfolio_values, risk_free_rate = 0.03) {
  # calculate monthly returns from portfolio values
  returns <- diff(log(portfolio_values))
  # downside deviation (only negative returns)
  negative_returns <- returns[returns < 0]
  if(length(negative_returns) == 0) {
    downside_deviation <- 0
  } else {
    downside_deviation <- sd(negative_returns, na.rm = TRUE) * sqrt(12)  # annualized
  }
  
  excess_return <- irr - risk_free_rate
  if(downside_deviation == 0) {
    sortino <- Inf  # perfect - no downside
  } else {
    sortino <- excess_return / downside_deviation
  }
  return(sortino)
}

# function to calculate time spent in drawdown
calculate_time_in_drawdown <- function(portfolio_values) {
  cummax_values <- cummax(portfolio_values)
  drawdowns <- (portfolio_values / cummax_values) - 1
  time_in_dd <- mean(drawdowns < -0.001, na.rm = TRUE)  # allow for small rounding errors
  return(time_in_dd)
}

# function to calculate average drawdown when in drawdown
calculate_average_drawdown <- function(portfolio_values) {
  cummax_values <- cummax(portfolio_values)
  drawdowns <- (portfolio_values / cummax_values) - 1
  drawdown_periods <- drawdowns[drawdowns < -0.001]  # only periods in drawdown
  
  if(length(drawdown_periods) == 0) {
    avg_dd <- 0
  } else {
    avg_dd <- mean(drawdown_periods, na.rm = TRUE)
  }
  return(avg_dd)
}

# function to calculate Calmar ratio (IRR / abs(Max Drawdown))
calculate_calmar_ratio <- function(irr, portfolio_values) {
  max_dd <- abs(calculate_max_drawdown(portfolio_values))
  if(max_dd == 0) {
    calmar <- Inf
  } else {
    calmar <- irr / max_dd
  }
  return(calmar)
}

# comprehensive risk analysis function
analyze_dca_risk <- function(portfolio_values, irr, risk_free_rate = 0.03, strategy_name = "Portfolio") {
  
  risk_metrics <- list(
    strategy = strategy_name,
    irr = irr,
    max_drawdown = calculate_max_drawdown(portfolio_values),
    volatility = calculate_portfolio_volatility(portfolio_values),
    modified_sharpe = calculate_modified_sharpe(irr, portfolio_values, risk_free_rate),
    sortino_ratio = calculate_sortino_ratio(irr, portfolio_values, risk_free_rate),
    time_in_drawdown = calculate_time_in_drawdown(portfolio_values),
    avg_drawdown = calculate_average_drawdown(portfolio_values),
    calmar_ratio = calculate_calmar_ratio(irr, portfolio_values)
  )
  
  return(risk_metrics)
}

# function to create risk comparison table
create_risk_comparison <- function(portfolio_list, irr_list, strategy_names, risk_free_rate = 0.03) {
  
  risk_results <- list()
  
  for(i in seq_along(portfolio_list)) {
    risk_results[[i]] <- analyze_dca_risk(
      portfolio_list[[i]], 
      irr_list[[i]], 
      risk_free_rate, 
      strategy_names[i]
    )
  }
  
  # convert to data frame
  risk_df <- data.frame(
    Strategy = sapply(risk_results, function(x) x$strategy),
    IRR = round(sapply(risk_results, function(x) x$irr) * 100, 2),
    Max_Drawdown_pct = round(sapply(risk_results, function(x) x$max_drawdown) * 100, 2),
    Volatility_pct = round(sapply(risk_results, function(x) x$volatility) * 100, 2),
    Modified_Sharpe = round(sapply(risk_results, function(x) x$modified_sharpe), 3),
    Sortino_Ratio = round(sapply(risk_results, function(x) x$sortino_ratio), 3),
    Time_in_DD_pct = round(sapply(risk_results, function(x) x$time_in_drawdown) * 100, 1),
    Avg_DD_pct = round(sapply(risk_results, function(x) x$avg_drawdown) * 100, 2),
    Calmar_Ratio = round(sapply(risk_results, function(x) x$calmar_ratio), 3)
  )
  
  return(risk_df)
}


# compare all your strategies
portfolios <- list(dca_60_40, dca_full_equity, dca_mtum, dca_vttvx)
irrs <- list(irr_60_40$annual, irr_full_equity$annual, irr_mtum$annual, irr_vttvx$annual)
names <- c("60/40", "100% Equity", "100% Momentum", "Vanguard Target 2025")

risk_table <- create_risk_comparison(portfolios, irrs, names)
print(risk_table)
```
