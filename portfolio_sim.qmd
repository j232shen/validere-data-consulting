---
title: "Portfolio Simulations"
author: "Jane Shen"
format: html
editor: visual
---

```{r}
#| label: setup

library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)

source("ETL.R")
```

## Get data

```{r}
#| label: process-assets

# fixed asset universe
# SPY: large cap equity (for comparison)
# VTI: all public U.S. stocks
# VXUS: most non-U.S. stocks
# BND: broad U.S. investment-grade bonds
# BNDX: broad non-U.S. bonds

start_date <- "2013-06-05" # inception date for BNDX
end_date <- "2025-06-30"

tickers <- list(VTI = "VTI", VXUS = "VXUS", BND = "BND", BNDX = "BNDX")
clean_returns <- process_assets(tickers, from = start_date, to = end_date) # xts object

colnames(clean_returns)
```

## Optimization functions

```{r}
# optimize_portfolio <- function(returns, pspec) {
#   # run quarterly rebalancing backtest
#   opt.rebal <- optimize.portfolio.rebalancing(returns, pspec,
#                                               optimize_method="CVXR",
#                                               rebalance_on="months",
#                                               # training_period=3 * 252, # 3 years is the default
#                                               rolling_window=3 * 252)
# 
#   return(opt.rebal)
# }
# 
# 
# print_opt_summary <- function(opt.rebal) {
#   summary_results <- summary(opt.rebal)
#   annualized_return <- summary_results$annualized_returns 
#   paste0("Annualized return:", annualized_return)
# }
# 
# 
# get_opt_returns <- function(returns, opt.rebal) {
#   # extract optimal weights from optimization
#   weights <- extractWeights(opt.rebal)
#   weights <- weights[complete.cases(weights),]
# 
#   # compute optimized portfolio returns
#   opt.returns <- Return.rebalancing(returns, weights)
# 
#   return(opt.returns)
# }
# 
# 
# plot_backtest <- function(opt.returns) {
#   backtest.plot(opt.returns)
# }
# 
# 
# backtest_portfolio <- function(returns, pspec) {
#   opt.rebal <- optimize.portfolio(returns, pspec)
#   print_opt_summary(opt.rebal)
#   opt.returns <- get_opt_returns(returns, opt.rebal)
#   plot_backtest(opt.returns)
# }
```

```{r}
# reusable function for running portfolio simulation
backtest_portfolio <- function(returns, pspec) {
  opt.rebal <- optimize.portfolio.rebalancing(returns, pspec,
                                              optimize_method="CVXR",
                                              rebalance_on="months",
                                              # training_period=3 * 252, # 3 years is the default
                                              rolling_window=3 * 252)
  
  # extract optimal weights from regime-switching optimization  
  weights <- extractWeights(opt.rebal)  
  weights <- weights[complete.cases(weights),]  
    
  # compute optimized portfolio returns  
  returns <- Return.rebalancing(clean_returns, weights)  
  
  # get annualized performance metrics  
  summary_results <- summary(opt.rebal)  
  annualized_return <- summary_results$annualized_returns 
  
  # # plot backtest results
  # backtest.plot(returns)
  
  return(list(weights = weights, returns = returns))
}
```

## Define portfolio allocations

### 60/40 equities to bonds

```{r}
# create portfolio specification
pspec_1 <- portfolio.spec(assets = colnames(clean_returns))

# add full investment constraint
pspec_1 <- add.constraint(pspec_1, type = "full_investment")

# add group constraints
pspec_1 <- add.constraint(pspec_1, type = "group",
                          groups = list(equities = c(1, 2),  # US + global equities
                                        bonds = c(3, 4)),    # US + global bonds
                          group_min = c(0.58, 0.38),         # 60% equities, 40% bonds with some flexibility
                          group_max = c(0.62, 0.42))

# add nested constraints within asset class allocation
pspec_1 <- add.constraint(pspec_1, type = "group",  
                          groups = list(VTI = 1, VXUS = 2, BND = 3, BNDX = 4),  
                          group_min = c(0.34, 0.22, 0.26, 0.10), 
                          group_max = c(0.38, 0.26, 0.30, 0.14))

# add objectives: maximize mean return while minimizing var
pspec_1 <- add.objective(pspec_1, type = "return", name = "mean")  
pspec_1 <- add.objective(pspec_1, type = "risk", name = "ES")

results_1 <- backtest_portfolio(clean_returns, pspec_1)
```

### 100% equity

```{r}
# create portfolio specification
pspec_2 <- portfolio.spec(assets = colnames(clean_returns)[1:2])  # only equities

# add full investment constraint
pspec_2 <- add.constraint(pspec_2, type = "full_investment")

# add group constraints
pspec_2 <- add.constraint(pspec_2, type = "group",
                          groups = list(VTI = 1, VXUS = 2),
                          group_min = c(0.58, 0.38),  # 60% US, 40% global
                          group_max = c(0.62, 0.42))

# add objectives: maximize mean return while minimizing var
pspec_2 <- add.objective(pspec_2, type = "return", name = "mean")  
pspec_2 <- add.objective(pspec_2, type = "risk", name = "ES")

results_2 <- backtest_portfolio(clean_returns, pspec_2)
```

### 100% MTUM

```{r}
MTUM_returns <- process_assets(list("MTUM"), from = start_date, to = end_date) # xts object
colnames(MTUM_returns)

# Create a weight matrix that's always 100% MTUM (for consistency)  
mtum_dates <- index(MTUM_returns)  
mtum_weights <- xts(matrix(1, nrow=length(mtum_dates), ncol=1),   
                    order.by=mtum_dates)  
colnames(mtum_weights) <- "MTUM"  
  
# Use Return.rebalancing for consistency with your other portfolios  
MTUM_portfolio <- Return.rebalancing(MTUM_returns, mtum_weights)
```

## Group portfolios and simulate

```{r}
grouped_returns <- na.omit(merge(results_1$returns, results_2$returns, MTUM_portfolio, all=FALSE))  
names(grouped_returns) <- c("60/40", "100% Equity", "100% Momentum")  

backtest.plot(grouped_returns)
```
